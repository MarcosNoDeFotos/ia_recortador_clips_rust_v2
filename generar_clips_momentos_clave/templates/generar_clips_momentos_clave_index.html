<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Generar Clips - Momentos Clave</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        :root {
            --bg: #121212;
            --fg: #e0e0e0;
            --card-bg: #1e1e1e;
            --border-color: #333;
            --text-color: #e0e0e0;
        }
        body {
            background: var(--bg);
            color: var(--fg);
            font-family: sans-serif;
        }
        .header {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            background: var(--card-bg);
            border-bottom: 1px solid var(--border-color);
            color: var(--text-color);
            padding: 12px 0;
            margin-bottom: 20px;
            border-radius: 0 0 10px 10px;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
        }
        .back-button {
            position: absolute;
            left: 20px;
            background: transparent;
            color: var(--text-color);
            border: none;
            font-size: 1.3rem;
            cursor: pointer;
            transition: transform 0.2s, opacity 0.2s;
        }
        .back-button:hover {
            transform: translateX(-3px);
            opacity: 0.8;
        }
        .toast {
            visibility: hidden;
            min-width: 250px;
            background-color: #333;
            color: #fff;
            text-align: center;
            border-radius: 8px;
            padding: 12px;
            position: fixed;
            z-index: 1;
            left: 50%;
            bottom: 30px;
            transform: translateX(-50%);
            opacity: 0;
            transition: opacity 0.4s, bottom 0.4s;
        }
        .toast.show {
            visibility: visible;
            opacity: 1;
            bottom: 50px;
        }
    </style>
</head>
<body>
    <header class="header">
        <button class="back-button" onclick="window.location.href='/'">‚¨ÖÔ∏è</button>
        <h1>Generar Clips - Momentos Clave</h1>
    </header>
    <div class="max-w-4xl mx-auto space-y-6 px-4">
        <div class="flex justify-between items-center mb-3">
            <h2 class="text-xl">üìÅ V√≠deos disponibles</h2>
            <button id="addVideos" class="bg-blue-600 hover:bg-blue-700 px-4 py-2 rounded-lg">A√±adir v√≠deos</button>
        </div>
        <div id="videoList" class="space-y-2 bg-gray-800 p-4 rounded-lg"></div>
        <div class="flex justify-end">
            <button id="analizarBtn" class="bg-green-600 hover:bg-green-700 px-6 py-3 rounded-lg">Analizar momentos clave</button>
        </div>
        <div class="mt-6">
            <h2 class="text-xl mb-2">üìã Segmentos detectados</h2>
            <div id="clipsContainer" class="space-y-3 bg-gray-800 p-4 rounded-lg"></div>
        </div>
    </div>
    <div id="toast" class="toast"></div>
    <!-- Modal de progreso -->
    <div id="progressModal" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,0.7); z-index:100; align-items:center; justify-content:center;">
        <div id="progressModalContent" style="background:#222; color:#fff; padding:30px 40px; border-radius:12px; min-width:320px; max-width:90vw;">
            <h2 class="text-lg mb-2">Analizando momentos clave...</h2>
            <div id="progressText" style="margin-bottom:10px;">Preparando...</div>
            <div style="background:#444; border-radius:6px; height:18px; width:100%; margin-bottom:8px;">
                <div id="progressBar" style="background:#4caf50; height:100%; width:0%; border-radius:6px;"></div>
            </div>
        </div>
    </div>
    <!-- Modal de edici√≥n/generaci√≥n de clip -->
    <div id="clipModal" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,0.7); z-index:200; align-items:center; justify-content:center;">
        <div id="clipModalContent" style="background:#222; color:#fff; padding:30px 40px; border-radius:12px; min-width:320px; max-width:95vw;">
            <div class="flex justify-between items-center mb-3">
                <h3 id="modalTitle">Editar segmento</h3>
                <button id="closeModalBtn" class="bg-blue-600 px-3 py-1 rounded">Cerrar</button>
            </div>
            <div class="video-container" style="display:flex; flex-direction:column; align-items:center; gap:15px;">
                <video id="modalVideo" controls style="width:100%; max-width:640px; border-radius:8px; background:black;"></video>
                <div class="timeline-container" id="timelineTop" style="position:relative; width:100%; max-width:640px; height:10px; background:#444; border-radius:5px; margin-top:10px;">
                    <div class="progress-fill-top" id="progressFillTop" style="position:absolute; top:0; bottom:0; background:#7378ff; border-radius:5px;"></div>
                    <div class="scrub-handle" id="scrubHandle" style="position:absolute; top:-4px; width:12px; height:18px; background:#2a2aff; border-radius:4px; transform:translateX(-50%); cursor:pointer;"></div>
                </div>
                <div class="timeline-bottom" id="timelineBottom" style="position:relative; width:100%; max-width:640px; height:14px; background:#555; border-radius:7px; margin-top:12px;">
                    <div class="selection-range" id="selectionRange" style="position:absolute; top:0; height:100%; background:rgba(115,120,255,0.4); border-radius:5px;"></div>
                    <div class="marker" id="markerStart" style="position:absolute; top:-3px; width:8px; height:20px; border-radius:3px; background:#0078d7; transform:translateX(-50%); cursor:ew-resize;"></div>
                    <div class="marker" id="markerEnd" style="position:absolute; top:-3px; width:8px; height:20px; border-radius:3px; background:#e63946; transform:translateX(-50%); cursor:ew-resize;"></div>
                </div>
                <div class="btn-container" style="display:flex; flex-direction:column; gap:10px; width:100%; max-width:640px;">
                    <div class="btn-row" style="display:flex; align-items:center; gap:8px;">
                        <label class="small">Inicio:</label>
                        <input id="inputStart" type="text" readonly style="width:100px; text-align:center; padding:6px; background:rgba(255,255,255,0.05); border:1px solid #333; border-radius:4px; color:#fff;">
                        <button id="startDec" title="Restar 1s">‚¨ÖÔ∏è</button>
                        <button id="startInc" title="Sumar 1s">‚û°Ô∏è</button>
                    </div>
                    <div class="btn-row" style="display:flex; align-items:center; gap:8px;">
                        <label class="small">Fin:</label>
                        <input id="inputEnd" type="text" readonly style="width:100px; text-align:center; padding:6px; background:rgba(255,255,255,0.05); border:1px solid #333; border-radius:4px; color:#fff;">
                        <button id="endDec" title="Restar 1s">‚¨ÖÔ∏è</button>
                        <button id="endInc" title="Sumar 1s">‚û°Ô∏è</button>
                    </div>
                    <div class="btn-row segment-adjust-buttons" style="display:flex; gap:8px;">
                        <button id="segmentDec" title="Mover segmento 1s atr√°s">‚¨ÖÔ∏è Segmento atr√°s</button>
                        <button id="segmentInc" title="Mover segmento 1s adelante">Segmento adelante ‚û°Ô∏è</button>
                    </div>
                </div>
                <div class="mt-3 flex gap-2" style="justify-content:flex-end;">
                    <button id="generateClipBtn" class="bg-green-600 px-4 py-2 rounded">Generar clip</button>
                </div>
                <div id="genResult" class="mt-3 small"></div>
            </div>
        </div>
    </div>
    <script>
        let segmentosDetectados = [];
        let segmentosPorVideo = {};

        function showToast(msg, color = "#333") {
            const toast = document.getElementById("toast");
            toast.textContent = msg;
            toast.style.background = color;
            toast.className = "toast show";
            setTimeout(() => { toast.className = "toast"; }, 2500);
        }

        async function loadVideos() {
            const res = await fetch('/generar_clips_momentos_clave/listar_videos');
            const vids = await res.json();
            const segRes = await fetch('/generar_clips_momentos_clave/segmentos_por_video');
            segmentosPorVideo = await segRes.json();
            const container = document.getElementById('videoList');
            container.innerHTML = '';
            vids.forEach(v => {
                const count = segmentosPorVideo[v] || 0;
                const el = document.createElement('label');
                el.className = 'flex items-center space-x-3 hover:bg-gray-700 p-2 rounded cursor-pointer';
                el.innerHTML = `<input type="radio" name="video" value="${v}" class="form-radio h-5 w-5 text-blue-500">
                        <span>${v}</span>
                        ${count > 0 ? `<span class="text-xs text-green-400 ml-2">${count} segmentos</span>` : ''}`;
                container.appendChild(el);
            });
            // A√±adir listener para mostrar segmentos al seleccionar
            document.querySelectorAll('input[name="video"]').forEach(input => {
                input.onchange = () => mostrarSegmentosDeVideo(input.value);
            });
        }

        async function mostrarSegmentosDeVideo(video) {
            const res = await fetch('/generar_clips_momentos_clave/segmentos_de_video?video=' + encodeURIComponent(video));
            const segs = await res.json();
            renderClips(segs);
        }

        function formatTime(sec) {
            if (isNaN(sec)) return "00:00:00.00";
            const h = Math.floor(sec / 3600).toString().padStart(2, "0");
            const m = Math.floor((sec % 3600) / 60).toString().padStart(2, "0");
            const s = Math.floor(sec % 60).toString().padStart(2, "0");
            const ms = Math.floor((sec % 1) * 100).toString().padStart(2, "0");
            return `${h}:${m}:${s}.${ms}`;
        }

        // ---- Modal edici√≥n/generaci√≥n de clip ----
        let currentSegment = null;
        let videoDuration = 0;
        let markerStartPct = 0;
        let markerEndPct = 100;
        let scrubbing = false;
        let draggingMarker = null;
        let draggingRange = false;
        let dragOffset = 0;
        let wasPlayingBeforeDrag = false;
        let shiftPressed = false;
        let controlPressed = false;

        const clipModal = document.getElementById('clipModal');
        const modalVideo = document.getElementById('modalVideo');
        const inputStart = document.getElementById('inputStart');
        const inputEnd = document.getElementById('inputEnd');
        const generateClipBtn = document.getElementById('generateClipBtn');
        const genResult = document.getElementById('genResult');
        const timelineTop = document.getElementById('timelineTop');
        const timelineBottom = document.getElementById('timelineBottom');
        const scrubHandle = document.getElementById('scrubHandle');
        const progressFillTop = document.getElementById('progressFillTop');
        const markerStart = document.getElementById('markerStart');
        const markerEnd = document.getElementById('markerEnd');
        const selectionRange = document.getElementById('selectionRange');
        const startDecBtn = document.getElementById('startDec');
        const startIncBtn = document.getElementById('startInc');
        const endDecBtn = document.getElementById('endDec');
        const endIncBtn = document.getElementById('endInc');
        const segmentDecBtn = document.getElementById('segmentDec');
        const segmentIncBtn = document.getElementById('segmentInc');

        document.addEventListener('keydown', e => {
            if (e.key === "Shift" && !shiftPressed) { shiftPressed = true; }
            if (e.key === "Control" && !controlPressed) { controlPressed = true; }
        });
        document.addEventListener('keyup', e => {
            if (e.key === "Shift") { shiftPressed = false; }
            if (e.key === "Control") { controlPressed = false; }
        });

        modalVideo.onloadedmetadata = () => {
            videoDuration = modalVideo.duration;
            updateMarkers();
        };

        modalVideo.ontimeupdate = () => {
            if (!videoDuration) return;
            const current = modalVideo.currentTime;
            const startTime = (markerStartPct / 100) * videoDuration;
            const endTime = (markerEndPct / 100) * videoDuration;
            const normPct = ((current - startTime) / (endTime - startTime)) * (markerEndPct - markerStartPct) + markerStartPct;
            progressFillTop.style.left = markerStartPct + "%";
            progressFillTop.style.width = (normPct - markerStartPct) + "%";
            scrubHandle.style.left = normPct + "%";
            if (current >= endTime) {
                modalVideo.currentTime = startTime;
                modalVideo.play();
            }
        };

        function clamp(v, min, max) { return Math.min(Math.max(v, min), max); }

        function updateMarkers() {
            markerStart.style.left = markerStartPct + "%";
            markerEnd.style.left = markerEndPct + "%";
            selectionRange.style.left = markerStartPct + "%";
            selectionRange.style.width = (markerEndPct - markerStartPct) + "%";
            const sSec = (markerStartPct / 100) * videoDuration;
            const eSec = (markerEndPct / 100) * videoDuration;
            inputStart.value = formatTime(sSec);
            inputEnd.value = formatTime(eSec);
            inputStart.dataset.sec = sSec;
            inputEnd.dataset.sec = eSec;
        }

        function restartMarkers() {
            markerStartPct = 0;
            markerEndPct = 100;
            modalVideo.currentTime = 0;
            updateMarkers();
        }

        startDecBtn.onclick = () => {
            let s = parseFloat(inputStart.dataset.sec);
            const timeToChange = shiftPressed && controlPressed ? 0.01 : shiftPressed ? 0.1 : 1;
            s = clamp(s - timeToChange, 0, parseFloat(inputEnd.dataset.sec) - 0.1);
            inputStart.dataset.sec = s;
            markerStartPct = (s / videoDuration) * 100;
            updateMarkers();
            modalVideo.currentTime = s;
            modalVideo.play();
        };
        startIncBtn.onclick = () => {
            let s = parseFloat(inputStart.dataset.sec);
            const timeToChange = shiftPressed && controlPressed ? 0.01 : shiftPressed ? 0.1 : 1;
            s = clamp(s + timeToChange, 0, parseFloat(inputEnd.dataset.sec) - 0.1);
            inputStart.dataset.sec = s;
            markerStartPct = (s / videoDuration) * 100;
            updateMarkers();
            modalVideo.currentTime = s;
            modalVideo.play();
        };

        endDecBtn.onclick = () => {
            let e = parseFloat(inputEnd.dataset.sec);
            const timeToChange = shiftPressed && controlPressed ? 0.01 : shiftPressed ? 0.1 : 1;
            e = clamp(e - timeToChange, parseFloat(inputStart.dataset.sec) + 0.1, videoDuration);
            inputEnd.dataset.sec = e;
            markerEndPct = (e / videoDuration) * 100;
            updateMarkers();
            const s = parseFloat(inputStart.dataset.sec);
            modalVideo.currentTime = Math.max(e - 3, s);
            modalVideo.play();
        };
        endIncBtn.onclick = () => {
            let e = parseFloat(inputEnd.dataset.sec);
            const timeToChange = shiftPressed && controlPressed ? 0.01 : shiftPressed ? 0.1 : 1;
            e = clamp(e + timeToChange, parseFloat(inputStart.dataset.sec) + 0.1, videoDuration);
            inputEnd.dataset.sec = e;
            markerEndPct = (e / videoDuration) * 100;
            updateMarkers();
            const s = parseFloat(inputStart.dataset.sec);
            modalVideo.currentTime = Math.max(e - 3, s);
            modalVideo.play();
        };

        segmentDecBtn.onclick = () => {
            let s = parseFloat(inputStart.dataset.sec);
            let e = parseFloat(inputEnd.dataset.sec);
            const duration = e - s;
            const timeToChange = shiftPressed && controlPressed ? 0.01 : shiftPressed ? 0.1 : 1;
            s = clamp(s - timeToChange, 0, videoDuration - duration);
            e = s + duration;
            markerStartPct = (s / videoDuration) * 100;
            markerEndPct = (e / videoDuration) * 100;
            updateMarkers();
            modalVideo.currentTime = s;
            modalVideo.play();
        };

        segmentIncBtn.onclick = () => {
            let s = parseFloat(inputStart.dataset.sec);
            let e = parseFloat(inputEnd.dataset.sec);
            const duration = e - s;
            const timeToChange = shiftPressed && controlPressed ? 0.01 : shiftPressed ? 0.1 : 1;
            e = clamp(e + timeToChange, duration, videoDuration);
            s = e - duration;
            markerStartPct = (s / videoDuration) * 100;
            markerEndPct = (e / videoDuration) * 100;
            updateMarkers();
            modalVideo.currentTime = s;
            modalVideo.play();
        };

        timelineTop.addEventListener("pointerdown", ev => {
            scrubbing = true;
            wasPlayingBeforeDrag = !modalVideo.paused;
            if (wasPlayingBeforeDrag) modalVideo.pause();
            timelineTop.setPointerCapture(ev.pointerId);
            handleScrub(ev);
        });
        timelineTop.addEventListener("pointermove", ev => {
            if (scrubbing) handleScrub(ev);
        });
        timelineTop.addEventListener("pointerup", ev => {
            if (scrubbing) {
                scrubbing = false;
                timelineTop.releasePointerCapture(ev.pointerId);
                modalVideo.play();
            }
        });

        function handleScrub(ev) {
            const rect = timelineTop.getBoundingClientRect();
            const x = clamp(ev.clientX - rect.left, 0, rect.width);
            const pct = (x / rect.width) * 100;
            const clamped = clamp(pct, markerStartPct, markerEndPct);
            const newTime = (clamped / 100) * videoDuration;
            modalVideo.currentTime = newTime;
            const startTime = (markerStartPct / 100) * videoDuration;
            const endTime = (markerEndPct / 100) * videoDuration;
            const normPct = ((newTime - startTime) / (endTime - startTime)) * (markerEndPct - markerStartPct) + markerStartPct;
            scrubHandle.style.left = normPct + "%";
            progressFillTop.style.left = markerStartPct + "%";
            progressFillTop.style.width = (normPct - markerStartPct) + "%";
        }

        // Markers dragging
        markerStart.addEventListener("pointerdown", ev => {
            draggingMarker = "start";
            document.body.classList.add("noselect");
            markerStart.setPointerCapture(ev.pointerId);
        });
        markerEnd.addEventListener("pointerdown", ev => {
            draggingMarker = "end";
            document.body.classList.add("noselect");
            markerEnd.setPointerCapture(ev.pointerId);
        });
        markerStart.addEventListener("pointermove", ev => handleMarkerDrag(ev, "start"));
        markerEnd.addEventListener("pointermove", ev => handleMarkerDrag(ev, "end"));
        markerStart.addEventListener("pointerup", ev => handleMarkerRelease(ev, "start"));
        markerEnd.addEventListener("pointerup", ev => handleMarkerRelease(ev, "end"));

        function handleMarkerDrag(ev, which) {
            if (draggingMarker !== which) return;
            const rect = timelineBottom.getBoundingClientRect();
            const x = clamp(ev.clientX - rect.left, 0, rect.width);
            const pct = (x / rect.width) * 100;
            const gap = 0.1;
            if (which === "start") {
                markerStartPct = clamp(pct, 0, markerEndPct - gap);
            } else {
                markerEndPct = clamp(pct, markerStartPct + gap, 100);
            }
            updateMarkers();
        }

        function handleMarkerRelease(ev, which) {
            if (draggingMarker !== which) return;
            ev.target.releasePointerCapture(ev.pointerId);
            document.body.classList.remove("noselect");
            if (which === "start") {
                modalVideo.currentTime = parseFloat(inputStart.dataset.sec);
                modalVideo.play();
            } else {
                const s = parseFloat(inputStart.dataset.sec);
                const e = parseFloat(inputEnd.dataset.sec);
                modalVideo.currentTime = Math.max(e - 3, s);
                modalVideo.play();
            }
            draggingMarker = null;
        }

        // Selection range dragging
        selectionRange.addEventListener("pointerdown", ev => {
            draggingRange = true;
            document.body.classList.add("noselect");
            selectionRange.setPointerCapture(ev.pointerId);
            const rect = timelineBottom.getBoundingClientRect();
            const x = clamp(ev.clientX - rect.left, 0, rect.width);
            dragOffset = x - (markerStartPct / 100) * rect.width;
        });
        selectionRange.addEventListener("pointermove", ev => {
            if (!draggingRange) return;
            const rect = timelineBottom.getBoundingClientRect();
            const x = clamp(ev.clientX - rect.left - dragOffset, 0, rect.width);
            const rangeWidth = ((markerEndPct - markerStartPct) / 100) * rect.width;
            let newStart = (x / rect.width) * 100;
            let newEnd = ((x + rangeWidth) / rect.width) * 100;
            const shift = newEnd > 100 ? newEnd - 100 : newStart < 0 ? newStart : 0;
            markerStartPct = clamp(newStart - shift, 0, 100);
            markerEndPct = clamp(newEnd - shift, 0, 100);
            updateMarkers();
        });
        selectionRange.addEventListener("pointerup", ev => {
            if (!draggingRange) return;
            selectionRange.releasePointerCapture(ev.pointerId);
            draggingRange = false;
            document.body.classList.remove("noselect");
            modalVideo.currentTime = parseFloat(inputStart.dataset.sec);
            modalVideo.play();
        });

        async function openClipModal(segment) {
            currentSegment = segment;
            clipModal.style.display = 'flex';
            genResult.innerHTML = '';
            document.getElementById('modalTitle').textContent = "Editar segmento: " + segment.clase;
            modalVideo.src = `/generar_clips_momentos_clave/video_original?video=${encodeURIComponent(segment.video_name)}`;
            setTimeout(() => {
                restartMarkers();
                inputStart.dataset.sec = segment.start || 0;
                markerStartPct = (inputStart.dataset.sec / videoDuration) * 100;
                inputEnd.dataset.sec = segment.end || 0;
                markerEndPct = (inputEnd.dataset.sec / videoDuration) * 100;
                updateMarkers();
                modalVideo.currentTime = parseFloat(inputStart.dataset.sec);
            }, 200);
        }

        document.getElementById('closeModalBtn').addEventListener('click', () => {
            clipModal.style.display = 'none';
            modalVideo.pause();
            modalVideo.src = "";
        });

        generateClipBtn.addEventListener('click', async () => {
            if (!currentSegment) return;
            const start = parseFloat(inputStart.dataset.sec);
            const end = parseFloat(inputEnd.dataset.sec);
            if (isNaN(start) || isNaN(end) || end <= start) return alert("Start/end inv√°lidos");
            generateClipBtn.disabled = true;
            genResult.innerHTML = "Generando...";
            const res = await fetch('/generar_clips_momentos_clave/generar_clip', {
                method: 'POST',
                headers: {'Content-Type':'application/json'},
                body: JSON.stringify({
                    video_name: currentSegment.video_name,
                    start: start,
                    end: end,
                    clase: currentSegment.clase
                })
            });
            const data = await res.json();
            generateClipBtn.disabled = false;
            if (data.success) {
                genResult.innerHTML = `Generado: <a href="${data.url}" target="_blank">${data.generated}</a>`;
                showToast("Clip generado correctamente", "#025902");
            } else {
                genResult.innerText = "Error: " + (data.error || "unknown");
                showToast("Error generando clip", "#c0392b");
            }
        });

        function showProgressModal(show=true) {
            document.getElementById('progressModal').style.display = show ? 'flex' : 'none';
        }
        function updateProgressModal(text, percent) {
            document.getElementById('progressText').textContent = text;
            document.getElementById('progressBar').style.width = percent + "%";
        }

        document.getElementById('addVideos').onclick = async () => {
            const res = await fetch('/generar_clips_momentos_clave/agregar_videos');
            const data = await res.json();
            if (data.success) loadVideos();
        };

        document.getElementById('analizarBtn').onclick = async () => {
            const selected = document.querySelector('input[name="video"]:checked');
            if (!selected) return alert('Selecciona un v√≠deo.');
            document.getElementById('analizarBtn').disabled = true;

            // Mostrar el modal de progreso antes de iniciar el an√°lisis
            showProgressModal(true);
            updateProgressModal("Iniciando...", 0);

            // Poll de progreso
            let polling = true;
            const poll = async () => {
                if (!polling) return;
                const res = await fetch('/generar_clips_momentos_clave/progreso?_=' + Date.now());
                const data = await res.json();
                updateProgressModal(data.log || "Procesando...", data.progress || 0);
                if (data.done) {
                    polling = false;
                    setTimeout(() => showProgressModal(false), 500);
                } else {
                    setTimeout(poll, 700);
                }
            };
            poll();

            // Iniciar an√°lisis
            const res = await fetch('/generar_clips_momentos_clave/detectar_momentos', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ video: selected.value })
            });
            const data = await res.json();
            document.getElementById('analizarBtn').disabled = false;
            if (data.success) {
                segmentosDetectados = data.segmentos;
                renderClips(segmentosDetectados);
                showToast("An√°lisis completado", "#025902");
                loadVideos();
            } else {
                showToast("Error: " + (data.error || "unknown"), "#c0392b");
            }
            polling = false;
            setTimeout(() => showProgressModal(false), 500);
        };

        // Estado de colapsado por clase y filtro de probabilidad
        let collapsedClasses = {};
        let probFilters = {};

        // Modificar renderClips y renderClassRows para agregar botones de eliminar
        function renderClips(segmentos) {
            const container = document.getElementById('clipsContainer');
            container.innerHTML = '';
            const grupos = {};
            segmentos.forEach(seg => {
                if (!grupos[seg.clase]) grupos[seg.clase] = [];
                grupos[seg.clase].push(seg);
            });
            for (const [clase, items] of Object.entries(grupos)) {
                if (collapsedClasses[clase] === undefined) collapsedClasses[clase] = false;
                if (probFilters[clase] === undefined) probFilters[clase] = 0;

                const section = document.createElement('div');
                section.className = 'p-3 rounded border border-gray-700';

                // Header con bot√≥n de colapsar, filtro de prob y eliminar clase
                const header = document.createElement('div');
                header.className = 'flex justify-between items-center mb-2';

                const left = document.createElement('div');
                left.style.display = 'flex';
                left.style.alignItems = 'center';
                left.style.gap = '10px';

                const collapseBtn = document.createElement('button');
                collapseBtn.textContent = collapsedClasses[clase] ? '‚ñ∂' : '‚ñº';
                collapseBtn.style.fontWeight = 'bold';
                collapseBtn.style.fontSize = '1.1em';
                collapseBtn.style.marginRight = '6px';
                collapseBtn.onclick = (e) => {
                    e.stopPropagation();
                    collapsedClasses[clase] = !collapsedClasses[clase];
                    renderClips(segmentos);
                };

                left.appendChild(collapseBtn);
                const labelSpan = document.createElement('span');
                labelSpan.innerHTML = `<strong>${clase}</strong> <span class="text-xs text-gray-400">(${items.length})</span>`;
                left.appendChild(labelSpan);

                // Bot√≥n eliminar clase
                const deleteClassBtn = document.createElement('button');
                deleteClassBtn.textContent = 'üóëÔ∏è Eliminar clase';
                deleteClassBtn.className = 'ml-2 bg-red-700 hover:bg-red-800 text-xs px-2 py-1 rounded text-white';
                deleteClassBtn.onclick = async (e) => {
                    e.stopPropagation();
                    // Tomar el video_name del primer segmento
                    const video_name = items[0].video_name;
                    await fetch('/generar_clips_momentos_clave/eliminar_clase', {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify({ video_name, clase })
                    });
                    showToast(`Clase "${clase}" eliminada`, "#c0392b");
                    // Refrescar segmentos
                    mostrarSegmentosDeVideo(video_name);
                    loadVideos();
                };
                left.appendChild(deleteClassBtn);

                // Filtro de probabilidad
                const filterDiv = document.createElement('div');
                filterDiv.style.display = 'flex';
                filterDiv.style.alignItems = 'center';
                filterDiv.style.gap = '6px';

                const filterLabel = document.createElement('label');
                filterLabel.className = "text-xs text-gray-400";
                filterLabel.textContent = "prob ‚â•";
                filterDiv.appendChild(filterLabel);

                const range = document.createElement('input');
                range.type = "range";
                range.min = "0";
                range.max = "1";
                range.step = "0.01";
                range.value = probFilters[clase];
                range.style.width = "80px";
                range.id = `probRange_${clase}`;
                filterDiv.appendChild(range);

                const val = document.createElement('span');
                val.className = "text-xs text-green-400";
                val.id = `probVal_${clase}`;
                val.textContent = parseFloat(probFilters[clase]).toFixed(2);
                filterDiv.appendChild(val);

                const maxProb = Math.max(...items.map(x=>x.avg_prob));
                const maxProbSpan = document.createElement('span');
                maxProbSpan.className = "text-xs text-gray-400";
                maxProbSpan.textContent = `Max prob: ${maxProb.toFixed(3)}`;
                filterDiv.appendChild(maxProbSpan);

                // Slider handler (direct, sin setTimeout)
                range.oninput = (e) => {
                    probFilters[clase] = parseFloat(e.target.value);
                    val.textContent = probFilters[clase].toFixed(2);
                    // No volver a renderizar todo, solo filtrar los rows de este grupo
                    renderClassRows(clase, items, section, probFilters[clase]);
                };

                header.appendChild(left);
                header.appendChild(filterDiv);
                section.appendChild(header);

                // Segmentos (solo si no est√° colapsado)
                if (!collapsedClasses[clase]) {
                    renderClassRows(clase, items, section, probFilters[clase]);
                }
                container.appendChild(section);
            }
        }

        function renderClassRows(clase, items, section, probFilter) {
            // Elimina los rows previos (pero no el header)
            while (section.children.length > 1) section.removeChild(section.lastChild);
            items
                .filter(it => it.avg_prob >= probFilter)
                .forEach(it => {
                    const row = document.createElement('div');
                    row.className = 'flex justify-between gap-4 items-center py-2 px-1 rounded hover:bg-gray-700 cursor-pointer';

                    // Bot√≥n eliminar segmento
                    const deleteBtn = document.createElement('button');
                    deleteBtn.textContent = 'üóëÔ∏è';
                    deleteBtn.title = 'Eliminar segmento';
                    deleteBtn.className = 'ml-2 bg-red-600 hover:bg-red-700 text-xs px-2 py-1 rounded text-white';
                    deleteBtn.onclick = async (e) => {
                        e.stopPropagation();
                        await fetch('/generar_clips_momentos_clave/eliminar_segmento', {
                            method: 'POST',
                            headers: {'Content-Type': 'application/json'},
                            body: JSON.stringify({
                                video_name: it.video_name,
                                clase: it.clase,
                                start: it.start,
                                end: it.end
                            })
                        });
                        showToast("Segmento eliminado", "#c0392b");
                        mostrarSegmentosDeVideo(it.video_name);
                        loadVideos();
                    };

                    row.innerHTML = `<div>
                        <span class="text-blue-300">${it.video_name}</span>
                        <span class="text-xs text-gray-400 ml-2">Inicio: ${formatTime(it.start)} ‚Ä¢ Fin: ${formatTime(it.end)}</span>
                    </div>
                    <div>
                        <span class="bg-gray-700 px-2 py-1 rounded text-xs">prob ${it.avg_prob.toFixed(3)}</span>
                    </div>`;
                    // Insertar el bot√≥n eliminar en la parte derecha
                    row.lastElementChild.appendChild(deleteBtn);

                    row.onclick = () => openClipModal(it);
                    section.appendChild(row);
                });
        }

        loadVideos();

        // Cerrar modales al hacer clic fuera
        document.getElementById('progressModal').addEventListener('mousedown', function(e) {
            if (e.target === this) {
                showProgressModal(false);
            }
        });
        document.getElementById('clipModal').addEventListener('mousedown', function(e) {
            if (e.target === this) {
                clipModal.style.display = 'none';
                modalVideo.pause();
                modalVideo.src = "";
            }
        });
    </script>
</body>
</html>
